Before we start the documentation, once again we have to say that we got help/assists from chatgpt and gemini ai, thank you.

Firstly, we started looking at our code and wonder how we can add more into it, and that's when it clicked that we should start simple first with emoji and rich text support. Knowing that python already support emojis, we knew that we needed rich text support now, so we implemented such practices, especially with chatgpt's help in terms of what hints it gave us, and we implemented after it clicked on us. We then ran the code and the code was able to support both emoji and rich text support.

Implemented SSL certification and private key. For now, the code will be using a self-signed certification for ease of use and testing, but will adjust in the future for proper protection. 

In part 1, we encountered the issue of a client requiring a response before it can send a message again, so we implemented a queue system that would separate the message / receive into different functions, allowing them to work in parallel, instead of messaging waiting on response. The user also had an issue with ease of use, so we implemented a simplistic GUI that will be updated with more flavor in a later iteration. This GUI is created upon running client.py, and introduces a white chatbox where you can type and send messages to other clients on the network, along with a better view of the chat. Our next goal will be introducing a database to store user and passwords, so we can identify the connected clients and allow each client to individually message each other.
Another aim is to update the way to connect, as localhost will not cut it. 

In addition to that, we chose to add in file sharing and a chat log system to see if that will function within our code, and it thankfully did. Although file sharing hasn't been ensured if it's fully completed or not, we learned that it works at the very least, which is what truly matters at the moment.

We looked into various methods to implement the login / register system and decided on using dictionaries to map the connection to a username and to track the state the client is in. State being whether they are logging in or registering. Our data storage is through a json file that stores the usernames plain and the passwords hashed. The server will read this json file when someone attempts to login, which will allows users to log out and relog whenever. Also introduced some requirements for passwords to ensure that users made a password that would not be solved too quickly. Also added some forbidden characters as a bandaid fix to prevent XSS attacks.
We then properly added a targeting system that is available in the GUI, which allows users to direct message other users - which is only possible because of the user / login system being properly implemeted. This feature is great, as previously, it was only possible to message all clients at once when sending messages. 
After implementing these changes, we added a way to target users for sending files, as the old system could only send messages. 
We also added the new URI which allows us to connect through a portforward DNS, meaning they no longer need to use localhost to connect each time. 
We then added brute force protection to logging in, added emoji support, and updated the logging for clients / server to ensure everything is properly timestamped and it creates a new one for each session. Introduced a file transfer state for transferring files to a specific user.
We then added client.exe for ease of access for the user, as they would no longer need to host from terminal to pop the GUI. 